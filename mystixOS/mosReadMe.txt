mystixO.S.




****Notes:*****
Philosophy:
 Every user should have full access to their system, with safety checks being in place by default,
 with the mechanism simply being that root access sits a few layers behind what is encountered first 
 (such as shell prompt being located a few folders deeper than a web browser icon and root access
 within the shell requiring command input to use system-level access and a simple confirmation)
  
 Customizability is key to ultimate experience of every individual, but greater customizability involves
 more work and understanding of the system than simply using a preset configuration. So design simple yet
 elegant user interfaces out of the box and enable full customization from there. Do so in a way that maintains
 simplistic elegance and maximum functionality as much as possible.
 
 

Ability to create unlimited desktop templates, with various function-based desktops being offered out of box,
such as ones filled with software shortcuts related to artistic, scientific, or business uses. 

Make great use of color and pattern themes for futuristic-looking designs. Research neuroscience to figure out
specific designs which can be used to improve cognitive abilities in various regards. 

Make the user manual visually beautiful while also extremely simple to navigate.

Full open source.

Study linux and BSD architechtures for ideas on how to intelligently design the system from beginning by considering the
system from start to end.

Maximum security.

Central design, decentralized control. 

Networking protocols considered and designed from the start. Will require a complete redesign from the current
internet infrastructure. 

Make it as simple as possible for users to learn how to go from basic to advanced understand of how to use the system.
Include tutorials in the manual folder. Utilize colorful graphics to make content look more interesting and easier for 
people to focus on/learn from.

Keep uniform system throughout. Ex: Numbers all 0-based to help in learning process. 

Integrate learning systems throughout the design to help users of all experience levels understand the system from
programming languages up through high level functionalities.

**Keep things fucking simple!! No multiple vocab to express the same concept. No cryptic language and commands.
Provide full-word-typed commands/file names/etc by default, along with a default-provided alias, to allow users of
all experience levels to learn how to fully use the system as easily as possible, and allow people to create their own
aliases based on personal preferences. In linking with systems, ensure that custom aliases are connected with default
commands in order to enable full compatibility.

Learn from past systems to design forward-looking systems. 

Make system as modular as possible, to allow for both faster learning of how individual components work as well as making it as 
simple as possible to change the system according to future realizations.

Create (software) device classes which can be used by and guide (hardware) device types as much as possible (such as keyboards, printers, etc)

Design assembly language and higher level language (C-ish), plus core libraries to allow for maximum system access and learning speed.
Find balance between compiled and interpreted programs. If creating both, keep as many similarities between the two languages as possible to
enable the quickest possible learning curve.

Apply most accurate modern neuroscientific knowledge in designing the system and manual to enable best possible learning across
as many brain & learning types as possible. 




  
  
